/*Copyright 2009,2010,2011,2012,2013 Cl√©ment Mondon <clement.mondon@gmail.com>

	This file is part of project myscreen.

	myscreen is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	myscreen is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with myscreen.  If not, see http://www.gnu.org/licenses/.

*/

#include "myscreen-stats.h"

/* Extern variables defined in main/modules_list.c (autogenerated) */
extern char * (*main_mod[NB_MODULES_MAX])(); 	/* For each module, function to display stats */
extern char * modules_color[]; 						/* For each module, display color */
extern void (*exit_mod[NB_MODULES_MAX])();    /* For each module, function to exit */

/* Current configuration read by parse-config */
int current_conf[NB_MODULES_MAX];

/* Multiple usages var */
char line[LINE_SIZE + 1];

/* Flags to drive loops */
int stats_loop; /* While TRUE, display stats */
int main_loop;

/* Struct at least used by uptime, processes, RAM, SWAP, and  loadaverage modules */
struct sysinfo si;

const char * empty_string = "";


/*
 * Get sysinfo struct
 */
void get_sysinfo() {
	if (sysinfo(&si) == -1){
		perror("Fatal error of syscall sysinfo used at least by LOADAVERAGE,USERS,PROCS,RAM,SWAP");
		exit(EXIT_FAILURE);
	}
}

/*
 * Call module's function and display stat
 */
void display_module_stats(int module_idx){
	IFDEBUG(printf("(%d) [%s]\n", module_idx, main_mod[module_idx]()););
	IFNDEBUG((void)fputs(modules_color[module_idx], stdout);
		 (void)fputs(main_mod[module_idx](), stdout);)
}

/*
 * Display END and wait
 */
void end_wait(){
	/* Display's end */
	(void)puts(COLOR_END);
	(void)fflush(stdout);

	/* Waiting between two stats generation */
	(void)sleep(TIME);
}

/*
 * Exit of all modules
 */
static void exit_modules(int nb_modules){

	int cpt;

	for (cpt = 0; cpt < nb_modules ; cpt++ ){
		assert(cpt<NB_MODULES_MAX);
		exit_mod[current_conf[cpt]]();
	}
}

/*
** Display message pulled from the message queue
*/
static void display_message()
{
  /* debug */
  assert(msg_queue_peek());
  IFDEBUG(printf("(new message) [%s]\n", msg_queue_peek()));
  assert(msg_queue_pop());

  /* not debug */
  IFNDEBUG(fputs(msg_queue_peek(), stdout));
  IFNDEBUG((void)msg_queue_pop());
}


/*
** Call all module's functions without display the result.
*/
static void update_stats(int nb_modules)
{
  int cpt;

  for (cpt = 0; cpt < nb_modules; cpt++)
    {
      (void)main_mod[current_conf[cpt]]();
    }
}

/*
 * Loop to print stats
 */
static void loop_stat(int nb_modules){

	int cpt;

	assert(nb_modules<=NB_MODULES_MAX);

	while(stats_loop) {

		get_sysinfo();

		if (!msg_queue_is_empty()) {
			display_message();
			update_stats(nb_modules);
		}
		else {
			for(cpt=0;cpt<nb_modules;cpt++){
				(void) display_module_stats(current_conf[cpt]);
			}
		}

		/* Display END and wait between two stats's generation*/
		(void) end_wait();

		IFONESHOT(if ((stats_loop++) >= 30 ) stats_loop = FALSE; );
	}
}


/*
 * MAIN function
 */
int main (/*int argc, char ** argv*/)
{

	int nb_modules;
	main_loop = TRUE;

	DEBUG_INFO("Running in debug mode")

	/* Install signals */
	install_signals();

	/* Always True, also when myscreen-stats is stopped */
	while(TRUE){

		/* Loop to read_conf and init all modules , display stats, and exit modules */
		/* main_loop become false when receiving signal */
		while (main_loop){

			/* stats_loop become false when receiving signal */
			stats_loop=TRUE;

			/* current_conf initialisation and modules initiatlisation calls */
			DEBUG_INFO("Reading configuration file")
			nb_modules = get_configuration();

			assert(nb_modules>=0 && nb_modules <= NB_MODULES_MAX);

			/* MAIN LOOP (print all stats while stats_loop == TRUE ) */
			IFDEBUG_PRINT(" \n");
			DEBUG_INFO("Starting stats loop")
			loop_stat(nb_modules);

			/* Modules's exit calls */
			DEBUG_INFO("Exit of all modules")
			exit_modules(nb_modules);

			IFONESHOT(exit(EXIT_SUCCESS));

		}

		/* Stopped, waiting new signal setting main_loop at TRUE */
		(void)pause();
	}
}

